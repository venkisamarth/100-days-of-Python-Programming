# -*- coding: utf-8 -*-
"""day 59Decorators  in python  .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XYzfPhKyErlSA43f9blQnQTb67DPBMka

Python Decoraters in python

Python decorators are a powerful and versatile tool that allow you to modify the behavior of functions and methods. They are a way to extend the functionality of a function or method without modifying its source code.

A decorator is a function that takes another function as an argument and returns a new function that modifies the behavior of the original function. The new function is often referred to as a "decorated" function. The basic syntax for using a decorator is the following:
"""

import logging

def log_function_call(func):
    def decorated(*args, **kwargs):
        logging.info(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        logging.info(f"{func.__name__} returned {result}")
        return result
    return decorated

@log_function_call
def my_function(a, b):
    return a + b

"""In this example, the log_function_call decorator takes a function as an argument and returns a new function that logs the function call before and after the original function is called."""

def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

"""Decorator with Arguments

"""

def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello!")

say_hello()

"""Timimg Decorator"""

import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Time taken: {end_time - start_time} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(2)
    print("Function executed.")

slow_function()

#Decorator with Authorization check

def authorize(user_type):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if user_type == "admin":
                return func(*args, **kwargs)
            else:
                raise PermissionError("Unauthorized access")
        return wrapper
    return decorator

@authorize(user_type="admin")
def sensitive_operation():
    print("Performing sensitive operation.")

sensitive_operation()

