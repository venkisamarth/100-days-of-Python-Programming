# -*- coding: utf-8 -*-
"""Decoraters in python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E39if0Wlp3PJpr8yKcPRKW44Ds95BH-q

Decorators in Python are a powerful and flexible way to modify or extend the behavior of functions or methods. Decorators are functions that take another function or method as input, add some functionality to it, and return the modified function. Here are 10 examples of decorators in Python with code and output:
"""

def my_Decorators(func):
  def wrapper():
    print('Somthing is happerning before the function is called.')
    func()
    print("Somthing is happerning after the Function is called.")
  return wrapper
@my_Decorators
def say_hello():
  print("Hello!")
say_hello()

# Decoraters with Parameters
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def say_hi(name):
    print(f"Hi, {name}!")

# Output:
# Hi, Alice!
# Hi, Alice!
# Hi, Alice!
say_hi("Alice")

"""Timing Decorator"""

import time
def timing_decorater(func):
  def wrapper(*args,**kwargs):
    start_time=time.time()
    result=func(*args,**kwargs)
    end_time=time.time()
    print(f"Execution time{end_time-start_time} seconds")
    return result
  return wrapper
@timing_decorater
def slow_function():
  time.sleep(2)
  print("Function execccuted.")
slow_function()

# decorators for exception handling
def handle_exception(func):
  def wrapper(*args,**kwargs):
    try:
      result =func(*args,**kwargs)
    except Exception as e:
      result=f"An Error occurred due to: {str(e)}"
    return result
  return wrapper

@handle_exception
def divide(a,b):
  return a/b

result=divide(5,0)
print(result)

"""Memoization with a Decorator

"""

def memoize(func):
    cache = {}

    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]

    return wrapper

@memoize
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# Output:
# Calculating fibonacci(5)
# Calculating fibonacci(4)
# Calculating fibonacci(3)
# Calculating fibonacci(2)
# Calculating fibonacci(1)
# Calculating fibonacci(0)
# Calculating fibonacci(2)
# Calculating fibonacci(1)
# Calculating fibonacci(3)
# Calculating fibonacci(2)
# Calculating fibonacci(4)
# Calculating fibonacci(3)
# Calculating fibonacci(2)
# Calculating fibonacci(1)
# Calculating fibonacci(5)
result = fibonacci(5)
print(result)

def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function {func.__name__} with arguments {args} and keyword arguments {kwargs}")
        result = func(*args, **kwargs)
        print(f"Function {func.__name__} returned {result}")
        return result
    return wrapper

@log_function_call
def add(a, b):
    return a + b

# Output:
# Calling function add with arguments (3, 5) and keyword arguments {}
# Function add returned 8
result = add(3, 5)

"""Loggin Decorator"""

def log_function_call(func):
  def wrapper(*args,**kwargs):
    print(f"calling funcion {func.__name__} with arguments {args} and keyword arguments{kwargs} ")
    result=func(*args,**kwargs)
    print(f"Function{func.__name__} returnd {result}")
    return result
  return wrapper
@log_function_call
def add(a,b):
  return a+b

result=add(3,5)

# Authorization Decorator
def Authorization_required(role):
  def decorator(func):
    def wrapper(*args,**kwargs):
      if role =="admin":
         result = func(*args, **kwargs)
      else:
        result="Authorization error: Insufficient privileges."
      return result
    return wrapper
  return decorator
@Authorization_required(role="admin")
def View_sensitive_data():
  return "This is sensitive  data."
result =View_sensitive_data()
print(result)

def ensure_non_negative_result(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return max(0, result)
    return wrapper

@ensure_non_negative_result
def subtract(a, b):
    return a - b

# Output:
# 0
result = subtract(3, 5)
print(result)

#Decorator to convert the Result to Uppercase
def to_uppercase(func):
  def wrapper(*args,**kwargs):
    result=func(*args,**kwargs)
    return result.upper()
  return wrapper
@to_uppercase
def greet(name):
  return f"Hello,{name}"

result=greet("Alice")
print(result)

def singleton(cls):
    instances = {}

    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return wrapper

@singleton
class DatabaseConnection:
    def __init__(self, host, port):
        self.host = host
        self.port = port

# Creating instances
db1 = DatabaseConnection(host="localhost", port=5432)
db2 = DatabaseConnection(host="example.com", port=3306)

# Output:
# db1 and db2 are the same instance
print(db1 is db2)

