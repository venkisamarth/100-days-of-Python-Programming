# -*- coding: utf-8 -*-
"""Inheritance in python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YEhTIQq_J6SO6RqAZbDn8AybdaQODZQv
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Dog barks"

# Creating instances
animal_instance = Animal()
dog_instance = Dog()

# Using inherited method
print(animal_instance.speak())  # Output: Animal speaks
print(dog_instance.speak())     # Output: Animal speaks

# Using subclass-specific method
print(dog_instance.bark())

"""constructor in inheritance class"""

class Person:
    def __init__(self, name):
        self.name = name

    def introduce(self):
        return f"Hi, I'm {self.name}"

class Student(Person):
    def __init__(self, name, student_id):
        super().__init__(name)
        self.student_id = student_id

    def student_info(self):
        return f"{self.introduce()} and my student ID is {self.student_id}"

# Creating instances
person_instance = Person("John")
student_instance = Student("Alice", "12345")

# Using inherited method
print(person_instance.introduce())  # Output: Hi, I'm John
print(student_instance.introduce()) # Output: Hi, I'm Alice

# Using subclass-specific method
print(student_instance.student_info())

class Shape:
    def area(self):
        return 0

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

# Creating instances
shape_instance = Shape()
circle_instance = Circle(radius=5)

# Using overridden method
print(shape_instance.area())   # Output: 0
print(circle_instance.area())  # Output: 78.5

class A:
    def info(self):
        return "Class A"

class B:
    def info(self):
        return "Class B"

class C(A, B):
    pass

# Creating an instance
c_instance = C()

# Accessing methods from both base classes
print(c_instance.info())  # Output: Class A
print(C.mro())

class Vehicle:
    def start(self):
        return "Vehicle started"

class Car(Vehicle):
    def drive(self):
        return "Car is driving"

class Bike(Vehicle):
    def ride(self):
        return "Bike is riding"

# Creating instances
car_instance = Car()
bike_instance = Bike()

# Using methods from the base class
print(car_instance.start())  # Output: Vehicle started
print(bike_instance.start()) # Output: Vehicle started

# Using subclass-specific methods
print(car_instance.drive())  # Output: Car is driving
print(bike_instance.ride())  # Output: Bike is riding

# accessing the superclass Methods
class Parent:
  def show(self):
    return "Parent class method"
class Child(Parent):
  def show(self):
    #accesing superclass method using superclass()
    return super().show() +"overridden by Child class method"

#creating t an instance
child_instance=Child()
# using overridden method
print(child_instance.show())

# diamond problem (Ambiguity Resoultion)
class A:
  def info(self):
    return "Class A"
class B(A):
  def info(self):
    return "Class B"
class C(A):
  def info(self):
    return "Class C"
class D(B,C):
  pass
# creating an instance
d_instance=D()

# Resolving ambiguty using MRO
print(d_instance.info())
print(D.mro())

class A:
  def show(A):
    return "Class A"

class B(A):
  def show(self):
    return "Class B"
class C(A):
  def show(A):
    def show(self):
      return "class C"
class D(B,C):
  pass
d_instance=D()
#REsolving method ambiguity using MRO
print(d_instance.show())
print(D.mro())

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2

# Creating instances
circle_instance = Circle(radius=4)
square_instance = Square(side=5)

# Using abstract methods
print(circle_instance.area())  # Output: 50.24
print(square_instance.area())  # Output: 25

class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        real_sum = self.real + other.real
        imag_sum = self.imag + other.imag
        return ComplexNumber(real_sum, imag_sum)

    def __str__(self):
        return f"{self.real} + {self.imag}j"

# Creating instances
c1 = ComplexNumber(2, 3)
c2 = ComplexNumber(1, 4)

# Using operator overloading
result = c1 + c2
print(result)

# Polymorphism
class Animal:
  def make_sound(self):
    pass
class Dog(Animal):
  def make_sound(self):
    return "Woof!"
class Cat(Animal):
  def make_sound(self):
    return "Meow!"
#CReating instance
dog_instane =[dog_instance,cat_instance]
for animal in animals:
  print(animal.make_sound())

class Shape:
    def area(self):
        return 0

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2

# Creating instances
circle_instance = Circle(radius=4)
square_instance = Square(side=5)

# Using overridden methods
print(circle_instance.area())  # Output: 50.24
print(square_instance.area())  # Output: 25

class BaseClass:
    def base_method(self):
        return "Base method"

# Creating an instance of the base class
base_instance = BaseClass()

# Dynamically creating a subclass with additional method
DynamicSubclass = type("DynamicSubclass", (BaseClass,), {"additional_method": lambda self: "Additional method"})

# Creating an instance of the dynamically created subclass
dynamic_instance = DynamicSubclass()

# Using methods from both classes
print(base_instance.base_method())          # Output: Base method
print(dynamic_instance.base_method())       # Output: Base method
print(dynamic_instance.additional_method())

